{"version":3,"file":"soucouyant.umd.js","sources":["../src/cache.js","../src/accumilator.js","../src/create-address.js","../src/state-object.js","../src/collection.js"],"sourcesContent":["// A cache to register the usage of various methods.\nexport default {\n\tsubscriptions: {},\n\tsuspend: {},\n}","import cache from './cache';\n\n/** \n Accumilates frames.\n\n**/\nconst accumilator = [\n    []\n];\nconst uniqueStateReferences = [];\n\nconst persistence = {\n    options: {\n        mergeFidelity: 0,\n    }\n};\n\n// Update settings.\nexport const persistenceSettings = options => Object.assign(persistence.options, options);\n\n\n// Adds a new state to the accumilator \n// May create a new frame to do so.\nexport const addNewState = (state, identity) => {\n    const currentTimeStamp = Date.now();\n    const mergeFidelity = persistence.options.mergeFidelity;\n    // Check unique states and add the state if does not yet exist.\n    // Directly reference the existing state.\n    const stateAsString = JSON.stringify(state);\n    const uniqueStateReferencesLength = uniqueStateReferences.length;\n\n    let stateExist = false;\n    let directReference;\n    for (let i = 0; i < uniqueStateReferencesLength; i++) {\n        const uniqueState = uniqueStateReferences[i];\n        const hasExistingState = JSON\n            .stringify(uniqueState) === stateAsString;\n        if (hasExistingState) {\n            directReference = uniqueState;\n            stateExist = true;\n            break;\n        }\n    }\n\n    if (stateExist === false) {\n        uniqueStateReferences.push(state);\n        directReference = uniqueStateReferences[uniqueStateReferences.length - 1];\n    }\n\n    // Find frame by timestamp\n    const accumilatorLength = accumilator.length;\n    const lastFrame = accumilator[accumilatorLength - 1];\n    const lastFrameTimeStamp = lastFrame[0];\n\n    // If within proximity merge. \n    const withinMergePeriod = lastFrameTimeStamp + mergeFidelity > currentTimeStamp;\n    if (withinMergePeriod) {\n        // merge to last frame\n        lastFrame.push([identity, directReference]);\n    } else {\n        // Add new frame.\n        accumilator.push([\n            currentTimeStamp, [\n                identity,\n                directReference\n            ]\n        ]);\n    }\n\n    // console.log('cache',cache)\n    const subscriptions = cache.subscriptions;\n    // Execute subscriptions\n    if (subscriptions[identity] === undefined) {\n        subscriptions[identity] = {};\n    }\n    const subIdentity = subscriptions[identity];\n    const subIdentityLength = Object.keys(subIdentity).length;\n\n    for(let ref in subIdentity){\n        subIdentity[ref](directReference, identity, currentTimeStamp);\n    }\n\n    // console.log('accumilator', JSON.stringify(accumilator, null, '\\t'));\n}\n\nexport const getCurrentState = (identity) => {\n    const accumilatorLength = accumilator.length;\n    for (let i = accumilatorLength; i > -1; --i) {\n        const frame = accumilator[i] || [];\n        const frameLength = frame.length;\n        for (let j = 0; j < frameLength; j++) {\n            if (frame[j][0] === identity) {\n                return frame[j][1];\n            }\n        }\n    }\n}","import StateObject from './state-object';\nimport { addNewState, getCurrentState } from './accumilator';\nimport cache from './cache';\n\n/** \n * @param {*} state\n * @param {number} identity - the unique state subscription identifier\n */\nconst stateMachine = (state, identity) => {\n    const stateModifier = callback => {\n        const lastState = state === null ? getCurrentState(identity) : state;\n        const newState = callback(lastState);\n\n        // We only update state if return is undefined.\n        if (newState !== undefined) {\n            addNewState(newState, identity);\n            if (state !== null) {\n                state = null;\n            }\n        }\n        return newState;\n    }\n    /** \n     * subscribe method.\n     * @param {string} ref - subscription reference.\n     * @param {Function} callback - On subscribe callback\n     */\n    stateModifier.subscribe = (ref, callback) => {\n        if (cache.subscriptions[identity] === undefined) {\n            cache.subscriptions[identity] = {};\n            cache.suspend[identity] = {};\n        }\n        if (cache.subscriptions[identity][ref] === undefined) {\n            cache.suspend[identity][ref] = false;\n            cache.subscriptions[identity][ref] = (...parameters) => {\n                if (!cache.suspend[identity][ref]) {\n                    callback(...parameters);\n                }\n            };\n        } else {\n            console.error(`The subscriptions reference ${ref} is already in use for identity ${identity}`);\n        }\n    }\n\n    /** \n     * suspend method.\n     * @param {string} ref - subscription reference.\n     * @param {Function} callback - On subscribe callback\n     */\n    stateModifier.suspend = ref => {\n        cache.suspend[identity][ref] = true;\n    }\n\n    /** \n     * suspend method.\n     * @param {string} ref - subscription reference.\n     * @param {Function} callback - On subscribe callback\n     */\n    stateModifier.unsubscribe = ref => {\n        delete cache.subscriptions[identity][ref];\n    }\n\n    return stateModifier;\n}\n\n\n// Identity ensures that each \n// state has a unique key for the: \n// cacne.subscriptions[identity]\n// as an object.\n// That object then stores references for each\n// subscription. See above.\nlet identity = -1;\n/** \n * \n * @param {Array} addressParts - Namespaces separated by > \n * @param {number} count - 0.\n * @param {*} state\n * @param {number} length - Number of namespaces.\n * @param {boolean} isCollection - false.\n * @param {*} nextPart - null.\n */\nconst createAddress = (addressParts, count, state, length, isCollection, nextPart) => {\n    const newPart = (addressParts[count] + '').trim();\n    if (nextPart === null) {\n        // Creates the next property as an object.\n        // And assigns the nextPart as that property to \n        // recycle into it's self to add additional levels.\n        // Once!\n        if (StateObject[newPart] === undefined) {\n            nextPart = StateObject[newPart] = {};\n        } else {\n            nextPart = StateObject[newPart];\n        }\n    } else {\n        // Creates the next property as an object.\n        // And assigns the nextPart as that property to \n        // recycle into it's self to add additional levels.\n        // beyond the first (I think)\n        const isEndOfPath = count === length - 1;\n        if (nextPart[newPart] === undefined) {\n            identity++;\n            const machine = isEndOfPath ? isCollection ? state : stateMachine(state, identity) : {};\n            nextPart = nextPart[newPart] = machine; // Creates the next property as an object.\n            if (isEndOfPath) {\n                return;\n            }\n        } else {\n            nextPart = nextPart[newPart];\n            if (isEndOfPath) {\n                return;\n            }\n        }\n    }\n    count++;\n    createAddress(addressParts, count, state, length, isCollection, nextPart);\n}\n\nexport default createAddress;","import createAddress from './create-address';\n\n/** \n * State object is a side effect represented by the \"o\" letter.\n * It takes a namespace address separeated by forward arrows and \n * an inital state.\n *\n * @param {string} address - The namespace address of the state object.\n * @param {*} state - The value of the state.\n * @returns {Function} StateObject.\n */\nexport default function StateObject(address, state) {\n    const addressParts = address[0].split('>');\n    const addressPartsLength = addressParts.length;\n    createAddress(\n        addressParts,\n        0,\n        state,\n        addressPartsLength,\n        false,\n        null\n    );\n    return StateObject\n}","import StateObject from './state-object';\nimport createAddress from './create-address';\nimport { addNewState, getCurrentState } from './accumilator';\n\n/**\n Collections is still a work in progress. \n It has a fantastic concept that allows the dev \n to pass the collection outside of the api and \n then back in to be updated so they can make use of\n native array and object methods without having to \n re-implement them for the API thus keeping the \n library tiny. Collections is basically a psuedo\n dataset, think of arrays but with references.\n\n E.g. in a todoapp a collection will not require \n an id, it comes with one already.\n */\n\n\nconst checkType = type => {\n    switch (type) {\n        case Array:\n            return [];\n        case Object:\n            return '';\n        default:\n            return type;\n            // if (Array.isArray()) {\n            //     return type;\n            // }\n    }\n}\n\nlet identity  = -1;\nexport default (type, hasEntries = false) => {\n identity++;\n    // Get the corresponding dataset according to the type.\n    const dataset = checkType(type);\n    const isArray = Array.isArray(dataset);\n    const isObject = isArray ? false : ((dataset) + '').indexOf('Object') >= 0;\n\n    // Check if the array has entries.\n    const data = isArray && hasEntries ? type : dataset.map((item, i) => [i, item]);\n\n    // A Deletable clone. \n    let initalDataClone = Array.from(data);\n\n    // Inital update\n    addNewState(data, identity);\n\n    const properties = {\n        data,\n        initialData: initalDataClone, // Clone inital data.\n        get entries() {\n            return getCurrentState(identity);\n        },\n        get states() {\n            return this.data.map(entry => entry[1]);\n        },\n        get ids() {\n            return this.data.map(entry => entry[0]);\n        },\n        update(newEntries) {\n            addNewState(newEntries, identity);\n        },\n        get firstId() {\n            return this.data[0][0];\n        },\n        get lastId() {\n            const length = this.data.length;\n            return this.data[length - 1][0];\n        },\n        get nextId() {\n            const length = this.data.length;\n            return this.data[length - 1][0];\n        },\n        get lastIndex() {\n            return this.data.length - 1;\n        },\n        get nextIndex() {\n            return this.data.length;\n        },\n        get firstState() {\n            return this.data[0][1];\n        },\n        get lastState() {\n            const length = this.data.length - 1;\n            console.log(length)\n            return this.data[length][1];\n        },\n        get firstEntry() {\n            return this.data[0];\n        },\n        get lastEntry() {\n            const length = this.data.length;\n            return this.data[length - 1];\n        },\n        get length() {\n            return this.data.length;\n        },\n    }\n    // return properties;\n    return (address) => {\n\n        const addressParts = address[0].split('>');\n        const addressPartsLength = addressParts.length;\n\n        createAddress(\n            addressParts,\n            0,\n            properties,\n            addressPartsLength,\n            true,\n            null\n        );\n    }\n}\n\n\n\n// get lastRemovedIds(){\n// \treturn \n// }\n// get initalLength() {\n//     return initalDataClone.length;\n// }\n// get initalEntries() {\n//     return initalDataClone;\n// }\n// get initalIds() {\n//     return initalDataClone.map(entry => entry[0]);\n// }\n// get initalStates() {\n//     return initalDataClone.map(entry => entry[0]);\n// }"],"names":["accumilator","uniqueStateReferences","persistence","addNewState","state","identity","currentTimeStamp","Date","now","mergeFidelity","options","stateAsString","JSON","stringify","uniqueStateReferencesLength","length","stateExist","directReference","i","uniqueState","hasExistingState","push","accumilatorLength","lastFrame","lastFrameTimeStamp","withinMergePeriod","subscriptions","cache","undefined","subIdentity","subIdentityLength","Object","keys","ref","getCurrentState","frame","frameLength","j","stateMachine","stateModifier","lastState","newState","callback","subscribe","suspend","error","unsubscribe","createAddress","addressParts","count","isCollection","nextPart","newPart","trim","StateObject","isEndOfPath","machine","address","split","addressPartsLength","checkType","type","Array","hasEntries","dataset","isArray","isObject","indexOf","data","map","item","initalDataClone","from","properties","entries","states","entry","ids","newEntries","firstId","lastId","nextId","lastIndex","nextIndex","firstState","log","firstEntry","lastEntry"],"mappings":"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"}